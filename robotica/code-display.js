// Armazenar todos os códigos
const codeRepository = {
    'seguidor-linha': {
        title: 'Seguidor de Linha - RobotC',
        description: `<p>Este código implementa um algoritmo de seguidor de linha para o LEGO EV3 usando RobotC.</p>
                      <ul>
                          <li>Configuração dos sensores de cor</li>
                          <li>Calibração da linha preta/branca</li>
                          <li>Lógica de seguidor de linha</li>
                          <li>Controle de velocidade adaptativo</li>
                      </ul>`,
        code: `#pragma config(Sensor, S1,     corEsq,         sensorEV3_Color)
#pragma config(Sensor, S3,     ultra,          sensorNone)
#pragma config(Sensor, S4,     corDir,         sensorEV3_Color)
#pragma config(Motor,  motorA,          motorEsq,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          motorDir,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//VARIAVEIS GLOBAIS
int vel = 45;
int velRed=15;
//Calibrador na pista
int sensor_luz_esquerda_branco = 56;
int sensor_luz_esquerda_preto = 2;
int sensor_luz_direita_branco = 69;
int sensor_luz_direita_preto = 6;
int mediaEsquerda = (sensor_luz_esquerda_branco + sensor_luz_esquerda_preto) / 2;
int mediaDireita = (sensor_luz_direita_branco + sensor_luz_direita_preto) / 2;

int sDir = getColorReflected(corDir);
int sEsq = getColorReflected(corEsq);
void corCheck() {
    sDir = getColorReflected(corDir);
    sEsq = getColorReflected(corEsq);
}
task main()
{

    while (true){

        int var = 2;
        motor[motorEsq] = vel;
        motor[motorDir] = vel;
        //Pegar a cor refletida
        sEsq = getColorReflected(corEsq);
        displayTextLine(2, "Cor refletida: %d", sEsq);
        sDir = getColorReflected(corDir);
        displayTextLine(4, "Cor refletida: %d", sDir);

        //Frente (preto + preto)
        if (sEsq > mediaEsquerda && sDir > mediaDireita){
            motor[motorEsq] = vel;
            motor[motorDir] = vel;
        }


        //virar para direita (preto + branco)
        if(sEsq < mediaEsquerda && sDir > mediaDireita){
            do{
                corCheck();
                motor[motorEsq] = velRed/2.5; //var
                motor[motorDir] = -velRed/2.5;
                sleep(3);
            }while(sEsq < mediaEsquerda && sDir > mediaDireita)
        }

        //virar para esquerda (branco + preto)
        if(sEsq > mediaEsquerda && sDir < mediaDireita){
            do{
                corCheck();
                motor[motorEsq] = -velRed/2.5;
                motor[motorDir] = velRed/2.5; //var
                sleep(3);
            }while(sEsq > mediaEsquerda && sDir < mediaDireita);
        }

    }
}`
    },
    'identificacao-vitima': {
        title: 'Identificação da Bolinha - RobotC',
        description: `<p>Algoritmo para identificação de vítimas na competição de resgate.</p>
                      <ul>
                          <li>Detecção de cores usando sensor RGB</li>
                          <li>Cálculo de distância para abordagem</li>
                          <li>Protocolo de captura da vítima</li>
                      </ul>`,
        code: `#pragma config(Sensor, S1,     sensorCor,     sensorEV3_Color)
#pragma config(Sensor, S4,     sensorUltra,   sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB, motorGarra,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC, motorEsq,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD, motorDir,      tmotorEV3_Large, PIDControl, encoder)

const int DISTANCIA_VITIMA = 5;
const int COR_PRATA = 50;
const int COR_PRETA = 10;
const int VELOCIDADE_BASE = 30;
const int LIMIAR_LINHA = 30;
const float KP = 1.8;
const float KI = 0.015;
const float KD = 0.6;
const int MAX_CORRECAO = 25;
const int NUM_LEITURAS = 5;
const int DISTANCIA_DETECCAO = 15;
const int BATERIA_MINIMA = 20;

int erroAnterior = 0;
float integral = 0;
int vitimasResgatadas = 0;

void inicializarRobo() {
    resetMotorEncoder(motorEsq);
    resetMotorEncoder(motorDir);
    setSensorMode(sensorCor, modeEV3Color_Reflected);
    wait1Msec(1000);
    displayTextLine(1, "Robo pronto");
}

void seguirLinha() {
    int leituraCor = getColorReflected(sensorCor);
    int erro = leituraCor - LIMIAR_LINHA;
    integral += erro;
    int derivada = erro - erroAnterior;
    
    float correcao = KP * erro + KI * integral + KD * derivada;
    
    if (correcao > MAX_CORRECAO) correcao = MAX_CORRECAO;
    if (correcao < -MAX_CORRECAO) correcao = -MAX_CORRECAO;
    
    motor[motorEsq] = VELOCIDADE_BASE + correcao;
    motor[motorDir] = VELOCIDADE_BASE - correcao;
    
    erroAnterior = erro;
    wait1Msec(5);
}

void recalibrarSensor() {
    setSensorMode(sensorCor, modeEV3Color_Calibration);
    wait1Msec(1500);
    setSensorMode(sensorCor, modeEV3Color_Reflected);
    displayTextLine(5, "Sensor recalibrado");
}

void aproximarVitima() {
    while (getUSDistance(sensorUltra) > DISTANCIA_VITIMA) {
        int distancia = getUSDistance(sensorUltra);
        int velocidade = (distancia > 10) ? VELOCIDADE_BASE : VELOCIDADE_BASE / 2;
        motor[motorEsq] = velocidade;
        motor[motorDir] = velocidade;
        wait1Msec(5);
    }
    motor[motorEsq] = 0;
    motor[motorDir] = 0;
    wait1Msec(500);
}

void resgatarVitimaPreta() {
    motor[motorGarra] = 40;
    wait1Msec(800);
    motor[motorGarra] = 0;
    vitimasResgatadas++;
    displayTextLine(6, "Vitimas: %d", vitimasResgatadas);
}

void resgatarVitimaPrata() {
    motor[motorGarra] = 60;
    wait1Msec(1200);
    motor[motorGarra] = 0;
    vitimasResgatadas++;
    displayTextLine(6, "Vitimas: %d", vitimasResgatadas);
}

void retornarLinha() {
    motor[motorEsq] = -VELOCIDADE_BASE;
    motor[motorDir] = -VELOCIDADE_BASE;
    wait1Msec(500);
    motor[motorEsq] = VELOCIDADE_BASE;
    motor[motorDir] = -VELOCIDADE_BASE;
    wait1Msec(300);
    while (getColorReflected(sensorCor) > LIMIAR_LINHA) {
        motor[motorEsq] = VELOCIDADE_BASE;
        motor[motorDir] = -VELOCIDADE_BASE / 2;
        wait1Msec(5);
    }
}

void identificarVitima() {
    aproximarVitima();
    
    int somaLeituras = 0;
    for (int i = 0; i < NUM_LEITURAS; i++) {
        somaLeituras += getColorReflected(sensorCor);
        wait1Msec(40);
    }
    int corVitima = somaLeituras / NUM_LEITURAS;
    
    displayTextLine(3, "Cor: %d", corVitima);
    
    if (corVitima < COR_PRETA) {
        displayTextLine(4, "Vitima PRETA");
        resgatarVitimaPreta();
    } else if (corVitima > COR_PRATA) {
        displayTextLine(4, "Vitima PRATA");
        resgatarVitimaPrata();
    } else {
        displayTextLine(4, "Nao identificado");
        recalibrarSensor();
        identificarVitima();
    }
    retornarLinha();
}

task main() {
    inicializarRobo();
    while (true) {
        seguirLinha();
        if (getUSDistance(sensorUltra) < DISTANCIA_DETECCAO) {
            identificarVitima();
        }
        if (getBatteryLevel() < BATERIA_MINIMA) {
            displayTextLine(7, "Bateria critica");
            motor[motorEsq] = 0;
            motor[motorDir] = 0;
            break;
        }
    }
}`
    },
    'deteccao-oponente': {
        title: 'Detecção de Oponente - SUMO',
        description: `<p>Sistema de detecção e ataque para competições de SUMO.</p>
                      <ul>
                          <li>Detecção de borda usando sensor de reflexão</li>
                          <li>Localização do oponente com sensor ultrassônico</li>
                          <li>Estratégias de ataque e defesa</li>
                      </ul>`,
        code: `#pragma config(Sensor, S1,     sensorBorda,   sensorEV3_Color, modeEV3Color_Reflected)
#pragma config(Sensor, S4,     sensorFrontal, sensorEV3_Ultrasonic)
#pragma config(Motor,  motorC, motorEsq,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD, motorDir,      tmotorEV3_Large, PIDControl, encoder)

const int VALOR_BORDA = 10;
const int POTENCIA_ATAQUE = 100;
const int POTENCIA_BUSCA = 50;
const int DIST_ATAQUE = 25;
const int DIST_MINIMA = 10;
const int TEMPO_RE = 400;
const int TEMPO_GIRO = 600;
const float FATOR_AJUSTE = 0.8;
const int BATERIA_MINIMA = 20;
const int LEITURAS_BORDA = 3;

int modoBatalha = 0;
int oponentesDetectados = 0;

void inicializarRobo() {
    resetMotorEncoder(motorEsq);
    resetMotorEncoder(motorDir);
    setSensorMode(sensorBorda, modeEV3Color_Reflected);
    wait1Msec(800);
    displayTextLine(1, "Robo pronto");
}

bool detectarBorda() {
    int somaLeituras = 0;
    for (int i = 0; i < LEITURAS_BORDA; i++) {
        somaLeituras += getColorReflected(sensorBorda);
        wait1Msec(5);
    }
    return (somaLeituras / LEITURAS_BORDA) < VALOR_BORDA;
}

bool detectarOponente() {
    int distancia = getUSDistance(sensorFrontal);
    return distancia < DIST_ATAQUE && distancia > DIST_MINIMA;
}

void buscarOponente() {
    int distancia = getUSDistance(sensorFrontal);
    int ajuste = distancia < DIST_ATAQUE ? (distancia - DIST_MINIMA) * FATOR_AJUSTE : 0;
    
    motor[motorEsq] = POTENCIA_BUSCA + ajuste;
    motor[motorDir] = -(POTENCIA_BUSCA - ajuste);
    
    displayTextLine(2, "Busca: %d cm", distancia);
    displayTextLine(3, "Oponentes: %d", oponentesDetectados);
}

void atacarOponente() {
    int distancia = getUSDistance(sensorFrontal);
    int potencia = distancia < DIST_MINIMA ? POTENCIA_ATAQUE * FATOR_AJUSTE : POTENCIA_ATAQUE;
    
    motor[motorEsq] = potencia;
    motor[motorDir] = potencia;
    
    oponentesDetectados++;
    displayTextLine(2, "ATAQUE: %d cm", distancia);
    displayTextLine(3, "Oponentes: %d", oponentesDetectados);
}

void evitarBorda() {
    motor[motorEsq] = -POTENCIA_BUSCA;
    motor[motorDir] = -POTENCIA_BUSCA;
    wait1Msec(TEMPO_RE);
    
    motor[motorEsq] = -POTENCIA_BUSCA / 2;
    motor[motorDir] = POTENCIA_BUSCA / 2;
    wait1Msec(TEMPO_GIRO);
    
    while (getColorReflected(sensorBorda) < VALOR_BORDA) {
        motor[motorEsq] = POTENCIA_BUSCA;
        motor[motorDir] = -POTENCIA_BUSCA / 2;
        wait1Msec(5);
    }
    
    displayTextLine(2, "Evitando borda");
}

task main() {
    inicializarRobo();
    while (true) {
        if (getBatteryLevel() < BATERIA_MINIMA) {
            displayTextLine(4, "Bateria critica");
            motor[motorEsq] = 0;
            motor[motorDir] = 0;
            break;
        }
        
        if (detectarBorda()) {
            modoBatalha = 2;
            evitarBorda();
        } else if (detectarOponente()) {
            modoBatalha = 1;
            atacarOponente();
        } else {
            modoBatalha = 0;
            buscarOponente();
        }
        
        wait1Msec(5);
    }
}`
    }
    // Você pode adicionar mais códigos aqui conforme necessário
};

// Configuração dos eventos quando o DOM estiver pronto
document.addEventListener('DOMContentLoaded', function() {
    // Configurar botões de mostrar código
    const codeToggleButtons = document.querySelectorAll('.code-toggle');
    const codePopup = document.getElementById('code-popup');
    const closePopupButton = document.querySelector('.close-popup');
    const codePopupTitle = document.getElementById('code-popup-title');
    const codePopupContent = document.getElementById('code-popup-content');
    const codePopupDescription = document.getElementById('code-popup-description');
    
    // Adicionar evento de clique para todos os botões de mostrar código
    codeToggleButtons.forEach(button => {
        button.addEventListener('click', function() {
            const codeId = this.getAttribute('data-code');
            if (codeRepository[codeId]) {
                const codeData = codeRepository[codeId];
                
                // Preencher o popup com os dados do código selecionado
                codePopupTitle.textContent = codeData.title;
                codePopupDescription.innerHTML = codeData.description;
                codePopupContent.textContent = codeData.code;
                
                // Exibir o popup
                codePopup.classList.add('active');
                document.body.classList.add('popup-open');
            }
        });
    });
    
    // Fechar popup ao clicar no botão X
    closePopupButton.addEventListener('click', function() {
        codePopup.classList.remove('active');
        document.body.classList.remove('popup-open');
    });
    
    // Fechar popup ao pressionar a tecla ESC
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape' && codePopup.classList.contains('active')) {
            codePopup.classList.remove('active');
            document.body.classList.remove('popup-open');
        }
    });
    
    // Fechar popup ao clicar fora do conteúdo
    codePopup.addEventListener('click', function(event) {
        if (event.target === codePopup) {
            codePopup.classList.remove('active');
            document.body.classList.remove('popup-open');
        }
    });

    // Configurar os botões "Copiar Código"
    const copyCodeButtons = document.querySelectorAll('.copy-code');

    copyCodeButtons.forEach(button => {
        button.addEventListener('click', function() {
            const codeId = this.getAttribute('data-code');
            
            // Verificar se o código está carregado no popup
            if (codePopupContent && codePopupContent.textContent) {
                const codeToCopy = codePopupContent.textContent;

                // Copiar o código para a área de transferência
                navigator.clipboard.writeText(codeToCopy).then(() => {
                    this.textContent = 'Código Copiado!';
                    setTimeout(() => {
                        this.textContent = 'Copiar Código';
                    }, 2000);
                }).catch(err => {
                    console.error('Erro ao copiar o código:', err);
                });
            } else {
                console.error('Nenhum código encontrado para copiar.');
            }
        });
    });
});
